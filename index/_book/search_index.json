[
["3-chapter1.html", "Chapter 3 Data and nyctaxi Package 3.1 Data and Storage 3.2 ETL nyctaxi Package 3.3 Extract 3.4 Transform 3.5 Load 3.6 SQL Database Initialization 3.7 Source Code", " Chapter 3 Data and nyctaxi Package 3.1 Data and Storage 3.1.1 Yellow Taxi The total size of all yellow taxi trip data CSV files (from Jan 2010 to Dec 2016) is 191.38 GB, and NYC yellow taxi trip data from Jan 2009 to the most recent month can be found on NYC Taxi &amp; Limousine Commission (TLC). The data were collected and provided to the NYC TLC by technology providers authorized under the Taxicab &amp; Livery Passenger Enhancement Programs (TPEP/LPEP). The yellow taxi trip records include the following fields: pick-up and drop-off dates/times, pick-up and drop-off locations, trip distances, itemized fares, rate types, payment types, and driver-reported passenger counts. 3.1.2 Green Taxi The total size of green taxi trip data CSV files (from Aug 2013 to Dec 2016) is 7.8 GB, and green taxi trip data from Aug 2013 to the most recent month can be downloaded from NYC Taxi &amp; Limousine Commission (TLC). The data were collected and provided to the NYC TLC by technology providers authorized under the Taxicab &amp; Livery Passenger Enhancement Programs (TPEP/LPEP). The green taxi trip records include the following fields: pick-up and drop-off dates/times, pick-up and drop-off locations, trip distances, itemized fares, rate types, payment types, and driver-reported passenger counts. 3.1.3 Uber The total size of Uber pick-up data (over 4.5 million from Apr to Sep 2014 and 14.3 million from Jan to June 2015) is 4.3 MB, and thanks to FiveThirtyEight who obtained the data from NYC TLC by submitting a Freedom of Information Law request on July 20, 2015, these data are now open to public. The 2014 Uber data contains four variables: Data/Time (the date and time of the Uber pick-up), Lat (the latitude of the Uber pick-up), Lon (the longitude of the Uber pick-up), and Base (the TLC base company code affiliated with the Uber pickup). The 2015 Uber data contains four variables: Dispatching_base_num (the TLC base company code of the base that dispatched the Uber), Pickup_date (the date of the Uber pick-up), Affiliated_base_num (the TLC base company code affiliated with the Uber pickup), and locationID (the pick-up location ID affiliated with the Uber pickup). 3.1.4 Lyft The total size of weely-aggregated Lyft trip data (from Jan 2015 to Dec 2016) is 914.9 MB, and these data are open to public and weekly-aggregated Lyft data from 2015 to the most recent week can be found on NYC OpenData website. 3.1.5 Storage The total size of all CSV files of the four services is about 200 GB, and a laptop usually has memory less than or equal to 8GB. Limited memory constrains the amount of data that can be loaded by a personal computer. When users load data into R environment, R keeps them in memory; when the amount of data loaded into R environment gets close to the limit of a computerâ€™s memory, R becomes unresponsive or force quit the current session. Therefore, better ways to work with data that takes more space than 8 GB is needed. According to Weijia Zhang (2016), comparing to RAM, hard disk is often used to store medium-sized data, because it is affordable and are designed for storing large items permanently. However, retrieving data from hard drives usually takes about 1,000,000 times more time. 3.2 ETL nyctaxi Package etl is the parent package of nyctaxi. etl package provides a CRAN-friendly framework that allows R users to work with medium data without any knowledge in SQL database. The end result is a populated SQL database, but the user interaction takes place solely within R. It has three operations -extract, transfer, and load- which bring real-time data into local or remote databases. etl-dependent packages make medium data - too big to store in memory on a laptop- more accessible to a wider audience. Additionally, etl-dependent packages use SQL translation supported by dyplr. nyctaxi was initially designed to work with New York City taxi data, but later on Uber and Lyft data were added and the ETL functions are modified to be specialized in working with these data. This package compiled three major sources of hail service in New York City so that it is convenient for users to compare and contrast the performance of these three services. This package inherits functions from many packages: etl, dplyr, DBI, rlang, and stringr. Since SQL databases are good tools for medium data analysis, ETL functions build connection to a SQL database at the back end and convert R code automatically into SQL queries and send them to the SQL database to get data tables containing data of each hail service. Thus, users do not need to have any knowledge of SQL queries and they can draw in any subsets of the data from the SQL database in R. In general, extract.nyctaxi function download data of the four types of hail service data (yellow taxi, green taxi, uber, and lyft) from the corresponding sources. transform.nyctaxi uses different techniques to clean all four types of data to get then ready for the next step. extract.load loads the data user selected to a SQL database. nyctaxi lives on the Comprehensive R Archive Network (CRAN), and Packages can be installed with the install.packages() function in R. #install the package install.packages(&quot;nyctaxi&quot;) # load the package library(nyctaxi) Users need to create an etl object in order to apply the etl operations to it, and only the name of the SQL database, working directory, and type of SQL database need to be specified during initialization. If the type of SQL database is not specified, a local RSQLite database will be generated as default. # initializing an etl object db &lt;- src_mysql(&quot;nyctaxi&quot;, user = &quot;urname&quot;, host = &quot;host&quot;, password = &quot;pw&quot;) taxi &lt;- etl(&quot;nyctaxi&quot;, dir = &quot;~/Desktop/nyctaxi&quot;, db) In the example above, a folder called nyctaxi is created on the desktop and a connection to a MySQL database is generated. In the procession of initialization, a local folder contains two subfolders, raw and load, are also created under the directory the user specifies. raw folder stores data downloaded from online open sources, and load folder stores cleaned CSV data files that are ready to be loaded into SQL database. The ETL framework keeps data directly scraped from online data sources in their original forms. In this way, the original data is always available to users in case data corruption happens in later stages. After an etl object is created (nyctaxi is the etl object in this case), four parameters are needed to specify the data that users want: (1) obj: an etl object (2) years: a numeric vector giving the years. The default is the most recent year. (3) months: a numeric vector giving the months. The default is January to December. (4) type: a character variable giving the type of data the user wants to download. There are four types: yellow, green, uber, and lyft. The default is yellow. 3.3 Extract etl_extract.nyctaxi allows users to download New York City yellow taxi, green taxi, Uber, and Lyft data that are specific to their month of interest. 3.3.1 Yellow Taxi 3.3.2 Green Taxi 3.3.3 Uber 3.3.4 Lyft 3.4 Transform etl_extract.nyctaxi allows users to transform New York City yellow taxi, green taxi, Uber, and Lyft data into forms that are meaningful to users. 3.4.1 Yellow Taxi 3.4.2 Green Taxi 3.4.3 Uber 3.4.4 Lyft 3.5 Load etl_extract.nyctaxi allows users to load New York City yellow taxi, green taxi, Uber, and Lyft data into different data tables in a SQL database. 3.5.1 Yellow Taxi 3.5.2 Green Taxi 3.5.3 Uber 3.5.4 Lyft 3.6 SQL Database Initialization 3.6.1 Yellow Taxi 3.6.2 Green Taxi 3.6.3 Uber 3.6.4 Lyft 3.7 Source Code 3.7.1 ETL Extract etl_extract.etl_nyctaxi &lt;- function(obj, years = as.numeric(format(Sys.Date(),&#39;%Y&#39;)), months = 1:12, type = &quot;yellow&quot;,...) { #TAXI YELLOW----------------------------------------------------------------------- taxi_yellow &lt;- function(obj, years, months,...) { message(&quot;Extracting raw yellow taxi data...&quot;) remote &lt;- etl::valid_year_month(years, months, begin = &quot;2009-01-01&quot;) %&gt;% mutate_(src = ~file.path(&quot;https://s3.amazonaws.com/nyc-tlc/trip+data&quot;, paste0(&quot;yellow&quot;, &quot;_tripdata_&quot;, year, &quot;-&quot;, stringr::str_pad(month, 2, &quot;left&quot;, &quot;0&quot;), &quot;.csv&quot;))) tryCatch(expr = etl::smart_download(obj, remote$src, ...), error = function(e){warning(e)}, finally = warning(&quot;Only the following data are availabel on TLC: Yellow taxi data: 2009 Jan - last month&quot;))} #TAXI GREEN----------------------------------------------------------------------- taxi_green &lt;- function(obj, years, months,...) { message(&quot;Extracting raw green taxi data...&quot;) remote &lt;- etl::valid_year_month(years, months, begin = &quot;2013-08-01&quot;) %&gt;% mutate_(src = ~file.path(&quot;https://s3.amazonaws.com/nyc-tlc/trip+data&quot;, paste0(&quot;green&quot;, &quot;_tripdata_&quot;, year, &quot;-&quot;, stringr::str_pad(month, 2, &quot;left&quot;, &quot;0&quot;), &quot;.csv&quot;))) tryCatch(expr = etl::smart_download(obj, remote$src, ...), error = function(e){warning(e)}, finally = warning(&quot;Only the following data are availabel on TLC: Green taxi data: 2013 Aug - last month&quot;))} #UBER----------------------------------------------------------------------- uber &lt;- function(obj, years, months,...) { message(&quot;Extracting raw uber data...&quot;) raw_month_2014 &lt;- etl::valid_year_month(years = 2014, months = 4:9) raw_month_2015 &lt;- etl::valid_year_month(years = 2015, months = 1:6) raw_month &lt;- bind_rows(raw_month_2014, raw_month_2015) path = &quot;https://raw.githubusercontent.com/fivethirtyeight/uber-tlc-foil-response/master/uber-trip-data&quot; remote &lt;- etl::valid_year_month(years, months) remote_small &lt;- intersect(raw_month, remote) if (2015 %in% remote_small$year &amp;&amp; !(2014 %in% remote_small$year)){ #download 2015 data message(&quot;Downloading Uber 2015 data...&quot;) etl::smart_download(obj, &quot;https://github.com/fivethirtyeight/uber-tlc-foil-response/raw/master/uber-trip-data/uber-raw-data-janjune-15.csv.zip&quot;,...)} else if (2015 %in% remote_small$year &amp;&amp; 2014 %in% remote_small$year) { #download 2015 data message(&quot;Downloading Uber 2015 data...&quot;) etl::smart_download(obj, &quot;https://github.com/fivethirtyeight/uber-tlc-foil-response/raw/master/uber-trip-data/uber-raw-data-janjune-15.csv.zip&quot;,...) #download 2014 data small &lt;- remote_small %&gt;% filter_(~year == 2014) %&gt;% mutate_(month_abb = ~tolower(month.abb[month]), src = ~file.path(path, paste0(&quot;uber-raw-data-&quot;,month_abb,substr(year,3,4),&quot;.csv&quot;))) message(&quot;Downloading Uber 2014 data...&quot;) etl::smart_download(obj, small$src,...) } else if (2014 %in% remote_small$year &amp;&amp; !(2015 %in% remote_small$year)) { message(&quot;Downloading Uber 2014 data...&quot;) #file paths small &lt;- remote_small %&gt;% mutate_(month_abb = ~tolower(month.abb[month]), src = ~file.path(path, paste0(&quot;uber-raw-data-&quot;,month_abb,substr(year,3,4),&quot;.csv&quot;))) etl::smart_download(obj, small$src,...)} else {warning(&quot;The Uber data you requested are not currently available. Only data from 2014/04-2014/09 and 2015/01-2015/06 are available...&quot;)} } #LYFT----------------------------------------------------------------------- lyft &lt;- function(obj, years, months,...){ message(&quot;Extracting raw lyft data...&quot;) #check if the week is valid valid_months &lt;- etl::valid_year_month(years, months, begin = &quot;2015-01-01&quot;) base_url = &quot;https://data.cityofnewyork.us/resource/edp9-qgv4.csv&quot; valid_months &lt;- valid_months %&gt;% mutate_(new_filenames = ~paste0(&quot;lyft-&quot;, year, &quot;.csv&quot;)) %&gt;% mutate_(drop = TRUE) #only keep one data set per year year &lt;- valid_months[1,1] n &lt;- nrow(valid_months) for (i in 2:n) { if(year == valid_months[i-1,1]) { valid_months[i,6] &lt;- FALSE year &lt;- valid_months[i+1,1] } else { valid_months[i,6] &lt;- TRUE year &lt;- valid_months[i+1,1]} } row_to_keep = valid_months$drop valid_months &lt;- valid_months[row_to_keep,] #download lyft files, try two different methods first_try&lt;-tryCatch( download_nyc_data(obj, base_url, valid_months$year, n = 50000, names = valid_months$new_filenames), error = function(e){warning(e)},finally = &#39;method = &quot;libcurl&quot; fails&#39;) } if (type == &quot;yellow&quot;){taxi_yellow(obj, years, months,...)} else if (type == &quot;green&quot;){taxi_green(obj, years, months,...)} else if (type == &quot;uber&quot;){uber(obj, years, months,...)} else if (type == &quot;lyft&quot;){lyft(obj, years, months,...)} else {message(&quot;The type you chose does not exit...&quot;)} invisible(obj) } 3.7.2 ETL Transform etl_transform.etl_nyctaxi &lt;- function(obj, years = as.numeric(format(Sys.Date(),&#39;%Y&#39;)), months = 1:12, type = &quot;yellow&quot;,...) { #TAXI YELLOW---------------------------------------------------------------- taxi_yellow &lt;- function(obj, years, months) { message(&quot;Transforming yellow taxi data from raw to load directory...&quot;) #create a df of file path of the files that the user wants to transform remote &lt;- etl::valid_year_month(years, months, begin = &quot;2009-01-01&quot;) %&gt;% mutate_(src = ~file.path(attr(obj, &quot;raw_dir&quot;), paste0(&quot;yellow&quot;, &quot;_tripdata_&quot;, year, &quot;-&quot;, stringr::str_pad(month, 2, &quot;left&quot;, &quot;0&quot;), &quot;.csv&quot;))) #create a df of file path of the files that are in the raw directory src &lt;- list.files(attr(obj, &quot;raw_dir&quot;), &quot;yellow&quot;, full.names = TRUE) src_small &lt;- intersect(src, remote$src) #Move the files in_raw &lt;- basename(src_small) in_load &lt;- basename(list.files(attr(obj, &quot;load_dir&quot;), &quot;yellow&quot;, full.names = TRUE)) file_remian &lt;- setdiff(in_raw,in_load) file.copy(file.path(attr(obj, &quot;raw_dir&quot;),file_remian), file.path(attr(obj, &quot;load_dir&quot;),file_remian) )} #TAXI GREEN---------------------------------------------------------------- taxi_green &lt;- function(obj, years, months) { message(&quot;Transforming green taxi data from raw to load directory...&quot;) #create a df of file path of the files that the user wants to transform remote &lt;- etl::valid_year_month(years, months, begin = &quot;2013-08-01&quot;) %&gt;% mutate_(src = ~file.path(attr(obj, &quot;raw_dir&quot;), paste0(&quot;green&quot;, &quot;_tripdata_&quot;, year, &quot;-&quot;, stringr::str_pad(month, 2, &quot;left&quot;, &quot;0&quot;), &quot;.csv&quot;))) #create a df of file path of the files that are in the raw directory src &lt;- list.files(attr(obj, &quot;raw_dir&quot;), &quot;green&quot;, full.names = TRUE) src_small &lt;- intersect(src, remote$src) #Clean the green taxi data files #get rid of 2nd blank row---------------------------------------------------------- if (length(src_small) == 0){ message(&quot;The files you requested are not available in the raw directory.&quot;) } else{ #a list of the ones that have a 2nd blank row remote_green_1 &lt;- remote %&gt;% filter_(~year != 2015) src_small_green_1 &lt;- intersect(src, remote_green_1$src) # check that the sys support command line, and then remove the blank 2nd row if(length(src_small_green_1) != 0) { if (.Platform$OS.type == &quot;unix&quot;){ cmds_1 &lt;- paste(&quot;sed -i -e &#39;2d&#39;&quot;, src_small_green_1) lapply(cmds_1, system) } else { message(&quot;Windows system does not currently support removing the 2nd blank row in the green taxi datasets. This might affect loading data into SQL...&quot;)} }else { &quot;You did not request for any green taxi data, or all the green taxi data you requested are cleaned.&quot;} #fix column number--------------------------------------------------------------- remote_green_2 &lt;- remote %&gt;% filter_(~year %in% c(2013, 2014, 2015)) %&gt;% mutate_(keep = ~ifelse(year %in% c(2013,2014), 20,21), new_file = ~paste0(&quot;green_tripdata_&quot;, year, &quot;_&quot;, stringr::str_pad(month, 2, &quot;left&quot;, &quot;0&quot;), &quot;.csv&quot;)) src_small_green_2 &lt;- intersect(src, remote_green_2$src) src_small_green_2_df &lt;- data.frame(src_small_green_2) names(src_small_green_2_df) &lt;- &quot;src&quot; src_small_green_2_df &lt;- inner_join(src_small_green_2_df, remote_green_2, by = &quot;src&quot;) src_small_green_2_df &lt;- src_small_green_2_df %&gt;% mutate(cmds_2 = paste(&quot;cut -d, -f1-&quot;, keep,&quot; &quot;,src, &quot; &gt; &quot;,attr(obj, &quot;raw_dir&quot;),&quot;/green_tripdata_&quot;, year, &quot;_&quot;, stringr::str_pad(month, 2, &quot;left&quot;, &quot;0&quot;),&quot;.csv&quot;, sep = &quot;&quot;)) #remove the extra column if(length(src_small_green_2) != 0) { if (.Platform$OS.type == &quot;unix&quot;){ lapply(src_small_green_2_df$cmds_2, system)} else { message(&quot;Windows system does not currently support removing the 2nd blank row in the green taxi datasets. This might affect loading data into SQL...&quot;)} }else { &quot;All the green taxi data you requested are in cleaned formats.&quot;} #Find the files paths of the files that need to be transformed---------------------- file.rename(file.path(dirname(src_small_green_2_df$src), src_small_green_2_df$new_file), file.path(attr(obj, &quot;load_dir&quot;), basename(src_small_green_2_df$src))) #Move the files in_raw &lt;- basename(src_small) in_load &lt;- basename(list.files(attr(obj, &quot;load_dir&quot;), &quot;green&quot;, full.names = TRUE)) file_remian &lt;- setdiff(in_raw,in_load) file.copy(file.path(attr(obj, &quot;raw_dir&quot;),file_remian), file.path(attr(obj, &quot;load_dir&quot;),file_remian) )}} #UBER---------------------------------------------------------------- uber &lt;- function(obj) { message(&quot;Transforming uber data from raw to load directory...&quot;) #creat a list of 2014 uber data file directory uber14_list &lt;- list.files(path = attr(obj, &quot;raw_dir&quot;), pattern = &quot;14.csv&quot;) uber14_list &lt;- data.frame(uber14_list) uber14_list &lt;- uber14_list %&gt;% mutate_(file_path = ~file.path(attr(obj, &quot;raw_dir&quot;), uber14_list)) uber14file &lt;- lapply(uber14_list$file_path, readr::read_csv) n &lt;- length(uber14file) if (n == 1) { uber14 &lt;- data.frame(uber14file[1]) } else if (n == 2) { uber14 &lt;- bind_rows(uber14file[1], uber14file[2]) } else if (n &gt; 2) { uber14 &lt;- bind_rows(uber14file[1], uber14file[2]) for (i in 3:n){uber14 &lt;- bind_rows(uber14, uber14file[i])} } substrRight &lt;- function(x, n){substr(x, nchar(x)-n+1, nchar(x))} uber14_datetime &lt;- uber14 %&gt;% mutate(date = gsub( &quot; .*$&quot;, &quot;&quot;, `Date/Time`), len_date = nchar(date), time = sub(&#39;.*\\\\ &#39;, &#39;&#39;, `Date/Time`)) uber14_datetime &lt;- uber14_datetime %&gt;% mutate(month = substr(`Date/Time`, 1, 1), day = ifelse(len_date == 8, substr(`Date/Time`, 3,3),substr(`Date/Time`, 3,4)), pickup_date = lubridate::ymd_hms(paste0(&quot;2014-&quot;, month, &quot;-&quot;, day, &quot; &quot;, time))) uber14_df &lt;- uber14_datetime[-c(1,5:9)] #2015 zipped_uberfileURL &lt;- file.path(attr(obj, &quot;raw_dir&quot;), &quot;uber-raw-data-janjune-15.csv.zip&quot;) raw_month_2015 &lt;- etl::valid_year_month(years = 2015, months = 1:6) remote_2015 &lt;- etl::valid_year_month(years, months) remote_small_2015 &lt;- inner_join(raw_month_2015, remote_2015) if(file.exists(zipped_uberfileURL) &amp;&amp; nrow(remote_small_2015) != 0){ utils::unzip(zipfile = zipped_uberfileURL, unzip = &quot;internal&quot;, exdir = file.path(tempdir(), &quot;uber-raw-data-janjune-15.csv.zip&quot;)) uber15 &lt;- readr::read_csv(file.path(tempdir(), &quot;uber-raw-data-janjune-15.csv.zip&quot;,&quot;uber-raw-data-janjune-15.csv&quot;))} names(uber14_df) &lt;- c(&quot;lat&quot;, &quot;lon&quot;, &quot;affiliated_base_num&quot;, &quot;pickup_date&quot;) names(uber15) &lt;- tolower(names(uber15)) uber &lt;- bind_rows(uber14_df, uber15) utils::write.csv(uber, file.path(tempdir() ,&quot;uber.csv&quot;)) if(nrow(uber) != 0) { if (.Platform$OS.type == &quot;unix&quot;){ cmds_3 &lt;- paste(&quot;cut -d, -f2-7 &quot;,file.path(tempdir(),&quot;uber.csv&quot;), &quot; &gt; &quot;, file.path(attr(obj, &quot;load_dir&quot;),&quot;uber.csv&quot;)) lapply(cmds_3, system) } else { message(&quot;Windows system does not currently support removing the 2nd blank row in the green taxi datasets. This might affect loading data into SQL...&quot;)} }else { &quot;You did not request for any green taxi data, or all the green taxi data you requested are cleaned.&quot;} } #LYFT---------------------------------------------------------------- lyft &lt;- function(obj, years, months){ valid_months &lt;- etl::valid_year_month(years, months = 1, begin = &quot;2015-01-01&quot;) message(&quot;Transforming lyft data from raw to load directory...&quot;) src &lt;- list.files(attr(obj, &quot;raw_dir&quot;), &quot;lyft&quot;, full.names = TRUE) src_year &lt;- valid_months %&gt;% distinct_(~year) remote &lt;- data_frame(src) remote &lt;- remote %&gt;% mutate_(lcl = ~file.path(attr(obj, &quot;load_dir&quot;),basename(src)), basename = ~basename(src), year = ~substr(basename,6,9)) class(remote$year) &lt;- &quot;numeric&quot; remote &lt;- inner_join(remote,src_year, by = &quot;year&quot; ) for(i in 1:nrow(remote)) { datafile &lt;- readr::read_csv(remote$src[i]) readr::write_delim(datafile, path = remote$lcl[i], delim = &quot;|&quot;, na = &quot;&quot;)}} #transform the data from raw to load if (type == &quot;yellow&quot;){taxi_yellow(obj, years, months)} else if (type == &quot;green&quot;){taxi_green(obj, years, months)} else if (type == &quot;uber&quot;){uber(obj)} else if (type == &quot;lyft&quot;){lyft(obj, years, months)} else {message(&quot;The type you chose does not exit...&quot;)} invisible(obj) } 3.7.3 ETL Load etl_load.etl_nyctaxi &lt;- function(obj, years = as.numeric(format(Sys.Date(),&#39;%Y&#39;)), months = 1:12, type = &quot;yellow&quot;, ...) { #TAXI YELLOW---------------------------------------------------------------- taxi_yellow &lt;- function(obj, years, months,...) { #create a df of file path of the files that are in the load directory src &lt;- list.files(attr(obj, &quot;load_dir&quot;), &quot;yellow&quot;, full.names = TRUE) src &lt;- data.frame(src) #files before 2016-07 remote_old &lt;- etl::valid_year_month(years, months, begin = &quot;2009-01-01&quot;, end = &quot;2016-06-30&quot;) %&gt;% mutate_(src = ~file.path(attr(obj, &quot;load_dir&quot;), paste0(&quot;yellow&quot;, &quot;_tripdata_&quot;, year, &quot;-&quot;, stringr::str_pad(month, 2, &quot;left&quot;, &quot;0&quot;), &quot;.csv&quot;))) src_small_old &lt;- inner_join(remote_old, src, by = &quot;src&quot;) #files later then 2017-06 remote_new &lt;- etl::valid_year_month(years, months, begin = &quot;2016-07-01&quot;) %&gt;% mutate_(src = ~file.path(attr(obj, &quot;load_dir&quot;), paste0(&quot;yellow&quot;, &quot;_tripdata_&quot;, year, &quot;-&quot;, stringr::str_pad(month, 2, &quot;left&quot;, &quot;0&quot;), &quot;.csv&quot;))) src_small_new &lt;- inner_join(remote_new, src, by = &quot;src&quot;) #data earlier than 2016-07 if(nrow(src_small_old) == 0) { message(&quot;The taxi files (earlier than 2016-07) you requested are not available in the load directory...&quot;) } else { message(&quot;Loading taxi data from load directory to a sql database...&quot;) mapply(DBI::dbWriteTable, name = &quot;yellow_old&quot;, value = src_small_old$src, MoreArgs = list(conn = obj$con, append = TRUE))} #data later then 2016-06 if(nrow(src_small_new) == 0) { message(&quot;The new taxi files (later than 2016-06) you requested are not available in the load directory...&quot;) } else { message(&quot;Loading taxi data from load directory to a sql database...&quot;) mapply(DBI::dbWriteTable, name = &quot;yellow&quot;, value = src_small_new$src, MoreArgs = list(conn = obj$con, append = TRUE))} } #TAXI GREEN---------------------------------------------------------------- taxi_green &lt;- function(obj, years, months,...) { #create a list of file that the user wants to load remote &lt;- etl::valid_year_month(years, months, begin = &quot;2013-08-01&quot;) %&gt;% mutate_(src = ~file.path(attr(obj, &quot;load_dir&quot;), paste0(&quot;green&quot;, &quot;_tripdata_&quot;, year, &quot;-&quot;, stringr::str_pad(month, 2, &quot;left&quot;, &quot;0&quot;), &quot;.csv&quot;))) #create a df of file path of the files that are in the load directory src &lt;- list.files(attr(obj, &quot;load_dir&quot;), &quot;tripdata&quot;, full.names = TRUE) src &lt;- data.frame(src) #only keep the files thst the user wants to transform src_small &lt;- inner_join(remote, src, by = &quot;src&quot;) if(nrow(src_small) == 0) { message(&quot;The taxi files you requested are not available in the load directory...&quot;) } else { message(&quot;Loading taxi data from load directory to a sql database...&quot;) mapply(DBI::dbWriteTable, name = &quot;green&quot;, value = src_small$src, MoreArgs = list(conn = obj$con, append = TRUE, ... = ...))}} #UBER---------------------------------------------------------------- uber &lt;- function(obj,...) { uberfileURL &lt;- file.path(attr(obj, &quot;load_dir&quot;), &quot;uber.csv&quot;) if(file.exists(uberfileURL)) { message(&quot;Loading uber data from load directory to a sql database...&quot;) DBI::dbWriteTable(conn = obj$con, name = &quot;uber&quot;, value = uberfileURL, append = TRUE, ... = ...) } else { message(&quot;There is no uber data in the load directory...&quot;)}} #LYFT---------------------------------------------------------------- lyft &lt;- function(obj, years, months,...){ message(&quot;Loading lyft data from load directory to a sql database...&quot;) #create a list of file that the user wants to load valid_months &lt;- etl::valid_year_month(years, months, begin = &quot;2015-01-01&quot;) src &lt;- list.files(attr(obj, &quot;load_dir&quot;), &quot;lyft&quot;, full.names = TRUE) src_year &lt;- valid_months %&gt;% distinct_(~year) remote &lt;- data_frame(src) remote &lt;- remote %&gt;% mutate_(tablename = ~&quot;lyft&quot;, year = ~substr(basename(src),6,9)) class(remote$year) &lt;- &quot;numeric&quot; remote &lt;- inner_join(remote,src_year, by = &quot;year&quot; ) if(nrow(remote) != 0) { write_data &lt;- function(...) { lapply(remote$src, FUN = DBI::dbWriteTable, conn = obj$con, name = &quot;lyft&quot;, append = TRUE, sep = &quot;|&quot;, ... = ...)} write_data(...) } else { message(&quot;The lyft files you requested are not available in the load directory...&quot;)}} if (type == &quot;yellow&quot;){taxi_yellow(obj, years, months,...) }else if (type == &quot;green&quot;){taxi_green(obj, years, months,...) }else if (type == &quot;uber&quot;){uber(obj,...) }else if (type == &quot;lyft&quot;){lyft(obj, years, months,...) }else {message(&quot;The type you chose does not exit...&quot;) } invisible(obj) } 3.7.4 utils This utility function below was written to shortened the source code in ETL extract. download_nyc_data &lt;- function(obj, url, years, n, names, ...) { url &lt;- paste0(url,&quot;?years=&quot;, years,&quot;&amp;$limit=&quot;, n) lcl &lt;- file.path(attr(obj, &quot;raw&quot;), names) downloader::download(url, destfile = lcl, ...) lcl } 3.7.5 ETL Init DROP TABLE IF EXISTS yellow_old; CREATE TABLE yellow_old ( VendorID tinyint DEFAULT NULL, tpep_pickup_datetime DATETIME NOT NULL, tpep_dropoff_datetime DATETIME NOT NULL, passenger_count tinyint DEFAULT NULL, trip_distance float(10,2) DEFAULT NULL, pickup_longitude double(7,5) DEFAULT NULL, pickup_latitude double(7,5) DEFAULT NULL, RatecodeID tinyint DEFAULT NULL, store_and_fwd_flag varchar(10) COLLATE latin1_general_ci DEFAULT NULL, dropoff_longitude double(7,5) DEFAULT NULL, dropoff_latitude double(7,5) DEFAULT NULL, payment_type tinyint DEFAULT NULL, fare_amount decimal(5,3) DEFAULT NULL, extra decimal(5,3) DEFAULT NULL, mta_tax decimal(5,3) DEFAULT NULL, tip_amount decimal(5,3) DEFAULT NULL, tolls_amount decimal(5,3) DEFAULT NULL, improvement_surcharge decimal(5,3) DEFAULT NULL, total_amount decimal(5,3) DEFAULT NULL, KEY VendorID (VendorID), KEY pickup_datetime (tpep_pickup_datetime), KEY dropoff_datetime (tpep_dropoff_datetime), KEY pickup_longitude (pickup_longitude), KEY pickup_latitude (pickup_latitude), KEY dropoff_longitude (dropoff_longitude), KEY dropoff_latitude (dropoff_latitude) ) PARTITION BY RANGE( YEAR(tpep_pickup_datetime) ) ( PARTITION p09 VALUES LESS THAN (2010), PARTITION p10 VALUES LESS THAN (2011), PARTITION p11 VALUES LESS THAN (2012), PARTITION p12 VALUES LESS THAN (2013), PARTITION p13 VALUES LESS THAN (2014), PARTITION p14 VALUES LESS THAN (2015), PARTITION p15 VALUES LESS THAN (2016), PARTITION p16 VALUES LESS THAN (2017) ); DROP TABLE IF EXISTS yellow; CREATE TABLE yellow ( VendorID tinyint DEFAULT NULL, tpep_pickup_datetime DATETIME NOT NULL, tpep_dropoff_datetime DATETIME NOT NULL, passenger_count tinyint DEFAULT NULL, trip_distance float(10,2) DEFAULT NULL, RatecodeID tinyint DEFAULT NULL, store_and_fwd_flag varchar(10) COLLATE latin1_general_ci DEFAULT NULL, PULocationID tinyint DEFAULT NULL, DOLocationID tinyint DEFAULT NULL, payment_type tinyint DEFAULT NULL, fare_amount decimal(5,3) DEFAULT NULL, extra decimal(5,3) DEFAULT NULL, mta_tax decimal(5,3) DEFAULT NULL, tip_amount decimal(5,3) DEFAULT NULL, tolls_amount decimal(5,3) DEFAULT NULL, improvement_surcharge decimal(5,3) DEFAULT NULL, total_amount decimal(5,3) DEFAULT NULL, KEY VendorID (VendorID), KEY pickup_datetime (tpep_pickup_datetime), KEY dropoff_datetime (tpep_dropoff_datetime), KEY PULocationID (PULocationID), KEY DOLocationID (DOLocationID) ) PARTITION BY RANGE( YEAR(tpep_pickup_datetime) ) ( PARTITION p16 VALUES LESS THAN (2017), PARTITION p17 VALUES LESS THAN (2018) ); DROP TABLE IF EXISTS green; CREATE TABLE green ( VendorID tinyint DEFAULT NULL, lpep_pickup_datetime DATETIME NOT NULL, Lpep_dropoff_datetime DATETIME NOT NULL, Store_and_fwd_flag varchar(10) COLLATE latin1_general_ci DEFAULT NULL, RatecodeID tinyint DEFAULT NULL, Pickup_longitude double(7,5) DEFAULT NULL, Pickup_latitude double(7,5) DEFAULT NULL, Dropoff_longitude double(7,5) DEFAULT NULL, Dropoff_latitude double(7,5) DEFAULT NULL, Passenger_count tinyint DEFAULT NULL, Trip_distance float(10,2) DEFAULT NULL, Fare_amount decimal(5,3) DEFAULT NULL, Extra decimal(5,3) DEFAULT NULL, MTA_tax decimal(5,3) DEFAULT NULL, Tip_amount decimal(5,3) DEFAULT NULL, Tolls_amount decimal(5,3) DEFAULT NULL, improvement_surcharge decimal(5,3) DEFAULT NULL, Total_amount decimal(5,3) DEFAULT NULL, Payment_type tinyint DEFAULT NULL, Trip_type tinyint DEFAULT NULL, KEY VendorID (VendorID), KEY pickup_datetime (lpep_pickup_datetime), KEY dropoff_datetime (Lpep_dropoff_datetime) ); DROP TABLE IF EXISTS lyft; CREATE TABLE lyft ( base_license_number varchar(15) COLLATE latin1_general_ci DEFAULT NULL, base_name varchar(40) COLLATE latin1_general_ci DEFAULT NULL, dba varchar(40) COLLATE latin1_general_ci DEFAULT NULL, pickup_end_date DATE NOT NULL, pickup_start_date DATE NOT NULL, total_dispatched_trips smallint DEFAULT NULL, unique_dispatched_vehicle smallint DEFAULT NULL, wave_number tinyint DEFAULT NULL, week_number tinyint DEFAULT NULL, years smallint DEFAULT NULL, KEY base_name (base_name), KEY pickup_end_date (pickup_end_date), KEY pickup_start_date (pickup_start_date) ); DROP TABLE IF EXISTS uber; CREATE TABLE uber ( lat double(7,5) DEFAULT NULL, lon double(7,5) DEFAULT NULL, dispatching_base_num varchar(15) COLLATE latin1_general_ci DEFAULT NULL, pickup_date DATETIME NOT NULL, affiliated_base_num varchar(15) COLLATE latin1_general_ci DEFAULT NULL, locationid tinyint DEFAULT NULL, KEY pickup_date (pickup_date), KEY locationid (locationid) ); CREATE VIEW yellow_old_sum AS SELECT YEAR(tpep_pickup_datetime) as the_year, MONTH(tpep_pickup_datetime) AS the_month, count(*) AS num_trips FROM yellow_old GROUP BY the_year, the_month; ); "]
]
